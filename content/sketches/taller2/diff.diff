1c1
< /*
---
> ï»¿/*
9c9
<     return ((n % m) + m) % m;
---
>   return ((n % m) + m) % m;
29,62c29,62
<     [
<         [0, 8, 0, 0],
<         [0, 8, 0, 0],
<         [0, 8, 0, 0],
<         [0, 8, 0, 0]
<     ],
<     [
<         [0, 0, 0],
<         [0, 2, 0],
<         [2, 2, 2]
<     ],
<     [
<         [3, 3,],
<         [3, 3,]
<     ],
<     [
<         [0, 0, 4],
<         [0, 0, 4],
<         [0, 4, 4]
<     ],
<     [
<         [5, 0, 0],
<         [5, 0, 0],
<         [5, 5, 0]
<     ],
<     [
<         [0, 0, 0],
<         [0, 6, 6],
<         [6, 6, 0],
<     ],
<     [
<         [0, 0, 0],
<         [7, 7, 0],
<         [0, 7, 7],
---
>   [
>     [0, 8, 0, 0],
>     [0, 8, 0, 0],
>     [0, 8, 0, 0],
>     [0, 8, 0, 0]
>   ],
>   [
>     [0, 0, 0],
>     [0, 2, 0],
>     [2, 2, 2]
>   ],
>   [
>     [3, 3],
>     [3, 3]
>   ],
>   [
>     [0, 0, 4],
>     [0, 0, 4],
>     [0, 4, 4]
>   ],
>   [
>     [5, 0, 0],
>     [5, 0, 0],
>     [5, 5, 0]
>   ],
>   [
>     [0, 0, 0],
>     [0, 6, 6],
>     [6, 6, 0],
>   ],
>   [
>     [0, 0, 0],
>     [7, 7, 0],
>     [0, 7, 7],
64c64
<     ]
---
>   ]
78,99c78,99
<     createCanvas(width, height, WEBGL);
<     angleMode(DEGREES);
<     frameRate(10);
<     // normalMaterial();
<     for (let i = 0; i < 18 + 1 + 4; i++)
<         gameMatrix.push([...Array(18).fill(0)]);
<     interval = setInterval('move_down()', 1000)
<     gameMatrix[0] = [...Array(18).fill(9)];
<     gameMatrix[18] = [...Array(18).fill(1)];
<     colors = {
<         1: color("#E0DDDD"),
<         2: color("#F9DC5C"),
<         3: color("#98F3F6"),
<         4: color("#F4FFFD"),
<         5: color("#C08AE9"),
<         6: color("#F39A9D"),
<         7: color("#C6ECAE"),
<         8: color("#FE55E4"),
<         9: color("#9f9f9f"),
<         10: color("#FF0034")
<     }
<     next_token();
---
>   createCanvas(width, height, WEBGL);
>   angleMode(DEGREES);
>   frameRate(10);
>   // normalMaterial();
>   for (let i = 0; i < 18 + 1 + 4; i++)
>     gameMatrix.push([...Array(18).fill(0)]);
>   interval = setInterval('move_down()', 1000)
>   gameMatrix[0] = [...Array(18).fill(9)];
>   gameMatrix[18] = [...Array(18).fill(1)];
>   colors = {
>     1: color("#E0DDDD"),
>     2: color("#F9DC5C"),
>     3: color("#98F3F6"),
>     4: color("#F4FFFD"),
>     5: color("#C08AE9"),
>     6: color("#F39A9D"),
>     7: color("#C6ECAE"),
>     8: color("#FE55E4"),
>     9: color("#9f9f9f"),
>     10: color("#FF0034")
>   }
>   next_token();
105,119c105,119
<     //To rotate the camera
<     if (keyIsDown(68) && try_move(3)) { //Derecha
<         i_token++;
<         cameraAngleRotation += 20;
<     }
<     if (keyIsDown(65) && try_move(2)) { //Izquierda
<         i_token--;
<         cameraAngleRotation -= 20;
<     }
<     if (keyIsDown(83)) {
<         move_down();
<     }
<     cameraAngleRotation %= 360;
<     camX = cos(cameraAngleRotation) * cameraDistance;
<     camZ = sin(cameraAngleRotation) * cameraDistance;
---
>   //To rotate the camera
>   if (keyIsDown(68) && try_move(3)) { //Derecha
>     i_token++;
>     cameraAngleRotation += 20;
>   }
>   if (keyIsDown(65) && try_move(2)) { //Izquierda
>     i_token--;
>     cameraAngleRotation -= 20;
>   }
>   if (keyIsDown(83)) {
>     move_down();
>   }
>   cameraAngleRotation %= 360;
>   camX = cos(cameraAngleRotation) * cameraDistance;
>   camZ = sin(cameraAngleRotation) * cameraDistance;
124,149c124,149
<     let new_token = Array();
<     let side = current_token[0].length
<     if (clockwise) {
<         for (let j = 0; j < side; j++) {
<             let new_token_row = Array();
<             for (let i = side - 1; i >= 0; i--) {
<                 new_token_row.push(current_token[i][j]);
<             }
<             new_token.push(new_token_row);
<         }
<     }
<     else {
<         for (let j = side - 1; j >= 0; j--) {
<             let new_token_row = Array();
<             for (let i = 0; i < side; i++) {
<                 new_token_row.push(current_token[i][j]);
<             }
<             new_token.push(new_token_row);
<         }
<     }
< 
<     for (let i = 0; i < current_token.length; i++) {
<         for (let j = 0; j < current_token.length; j++) {
<             if (new_token[i][j] && gameMatrix[mod(h_token - i, 24)][mod(i_token + j, 18)] > 1)
<                 return;
<         }
---
>   return;
>   let new_token = Array();
>   let side = current_token[0].length
>   if (clockwise) {
>     for (let j = 0; j < side; j++) {
>       let new_token_row = Array();
>       for (let i = side - 1; i >= 0; i--) {
>         new_token_row.push(current_token[i][j]);
>       }
>       new_token.push(new_token_row);
>     }
>   }
>   else {
>     for (let j = side - 1; j >= 0; j--) {
>       let new_token_row = Array();
>       for (let i = 0; i < side; i++) {
>         new_token_row.push(current_token[i][j]);
>       }
>       new_token.push(new_token_row);
>     }
>   }
> 
>   for (let i = 0; i < current_token.length; i++) {
>     for (let j = 0; j < current_token.length; j++) {
>       if (new_token[i][j] && gameMatrix[mod(h_token - i, 24)][mod(i_token + j, 18)] > 1)
>         return;
151c151,152
<     current_token = new_token;
---
>   }
>   current_token = new_token;
156,168c157,170
<     if (try_move(1))
<         h_token--;
<     else {
<         for (let i = 0; i < current_token.length; i++) {
<             for (let j = 0; j < current_token.length; j++) {
<                 if (current_token[i][j])
<                     gameMatrix[mod(h_token - i, 24)][mod(i_token + j, 18)] = current_token[i][j];
<             }
<         }
<         if (check_status()) return;
<         check_lines();
<         next_token();
<     }
---
>   if (try_move(1))
>     h_token--;
>   else {
>     for (let i = 0; i < current_token.length; i++) {
>       for (let j = 0; j < current_token.length; j++) {
>         if (current_token[i][j])
>           gameMatrix[mod(h_token - i, 24)][mod(i_token + j, 18)] = current_token[i][j];
>       }
>     }
>     if (check_status())
>       return;
>     check_lines();
>     next_token();
>   }
172,176c174,177
<     for (let i = 0; i < 18; i++) {
<         if (gameMatrix[18][i] > 1) {
<             lose()
<             return 1;
<         }
---
>   for (let i = 0; i < 18; i++) {
>     if (gameMatrix[18][i] > 1) {
>       lose()
>       return 1;
177a179
>   }
180,185c182,186
<     clearInterval(interval)
<     for (let i = 0; i < 18; i++) {
<         if (gameMatrix[18][i] > 1) {
<             // gameMatrix[18][i] = 10;
<             display(18, i, 10);
<         }
---
>   clearInterval(interval)
>   for (let i = 0; i < 18; i++) {
>     if (gameMatrix[18][i] > 1) {
>       // gameMatrix[18][i] = 10;
>       display(18, i, 10);
187c188,189
<     noLoop()
---
>   }
>   noLoop()
191c193
<     let lines = Array();
---
>   let lines = Array();
193,207c195,207
<     for (let i = 1; i < gameMatrix.length; i++) {
<         let cur_line = 0;
<         for (let j = 0; j < gameMatrix[0].length; j++) {
<             if (gameMatrix[i][j] != 0)
<                 cur_line++;
<         }
<         if (cur_line == gameMatrix.length)
<             lines.push(i);
<     }
<     for (let i = 0; i < lines.length; i++) {
<         let idx = lines[i];
<         for (let j = idx; j + 1 < gameMatrix.length; j++) {
<             gameMatrix[j] = [...gameMatrix[j + 1]];
<         }
<         gameMatrix[gameMatrix.length - 1] = [...Array(18).fill(0)]
---
>   for (let i = 1; i < gameMatrix.length; i++) {
>     let cur_line = 0;
>     for (let j = 0; j < gameMatrix[0].length; j++) {
>       if (gameMatrix[i][j] > 1)
>         cur_line++;
>     }
>     if (cur_line == gameMatrix[0].length)
>       lines.push(i);
>   }
>   for (let i = 0; i < lines.length; i++) {
>     let idx = lines[i];
>     for (let j = idx; j + 1 < gameMatrix.length; j++) {
>       gameMatrix[j] = [...gameMatrix[j + 1]];
208a209,210
>     gameMatrix[gameMatrix.length - 1] = [...Array(18).fill(0)]
>   }
213,227c215,228
<     // create a classic plane -> h positive to go up ad
<     translate(0, -1, 0);
<     checkKeys();
<     orbitControl();
< 
<     camera(camX, camY, camZ, centerX, centerY, centerZ, 0, -1, 0);
< 
<     background(240);
<     // strokeWeight(20)
<     // strokeWeight(1)
< 
<     for (let h = 0; h < gameMatrix.length; h += 1) {
<         for (let i = 0; i < gameMatrix[h].length; i += 1) {
<             display(h, i, gameMatrix[h][i]);
<         }
---
>   // create a classic plane -> h positive to go up ad
>   translate(0, -1, 0);
>   checkKeys();
>   orbitControl();
> 
>   camera(camX, camY, camZ, centerX, centerY, centerZ, 0, -1, 0);
> 
>   background(240);
>   // strokeWeight(20)
>   // strokeWeight(1)
> 
>   for (let h = 0; h < gameMatrix.length; h += 1) {
>     for (let i = 0; i < gameMatrix[h].length; i += 1) {
>       display(h, i, gameMatrix[h][i]);
228a230
>   }
230,234c232,235
<     for (let i = 0; i < current_token.length; i++) {
<         for (let j = 0; j < current_token.length; j++) {
<             // print(h_token)
<             display(mod(h_token - i, 24), mod(i_token + j, 18), current_token[i][j]);
<         }
---
>   for (let i = 0; i < current_token.length; i++) {
>     for (let j = 0; j < current_token.length; j++) {
>       // print(h_token)
>       display(mod(h_token - i, 24), mod(i_token + j, 18), current_token[i][j]);
235a237,238
>   }
> 
239,251c242,253
<     // 1 down
<     // 2 left
<     // 3 right
< 
<     let sum = 0;
< 
<     if (direction == 1) {
<         for (let i = 0; i < current_token.length; i++) {
<             for (let j = 0; j < current_token.length; j++) {
<                 if (current_token[i][j] != 0 && gameMatrix[mod(h_token - i - 1, 24)][mod(i_token + j, 18)] > 1) {
<                     sum++;
<                 }
<             }
---
>   // 1 down
>   // 2 left
>   // 3 right
> 
>   let sum = 0;
> 
>   if (direction == 1) {
>     for (let i = 0; i < current_token.length; i++) {
>       for (let j = 0; j < current_token.length; j++) {
>         if (gameMatrix[mod(h_token - i - 1, 24)][mod(i_token + j, 18)] > 1 && current_token[i][j] != 0) {
>           print(mod(h_token - i - 1, 24), mod(i_token + j, 18))
>           sum++;
253,259c255,261
<     } else if (direction == 2) {
<         for (let i = 0; i < current_token.length; i++) {
<             for (let j = 0; j < current_token.length; j++) {
<                 if (gameMatrix[mod(h_token - i, 24)][mod(i_token + j - 1, 18)] > 1 && current_token[i][j] != 0) {
<                     sum++;
<                 }
<             }
---
>       }
>     }
>   } else if (direction == 2) {
>     for (let i = 0; i < current_token.length; i++) {
>       for (let j = 0; j < current_token.length; j++) {
>         if (gameMatrix[mod(h_token - i, 24)][mod(i_token + j - 1, 18)] > 1 && current_token[i][j] != 0) {
>           sum++;
261,267c263,269
<     } else if (direction == 3) {
<         for (let i = 0; i < current_token.length; i++) {
<             for (let j = 0; j < current_token.length; j++) {
<                 if (gameMatrix[mod(h_token - i, 24)][mod(i_token + j + 1, 18)] > 1 && current_token[i][j] != 0) {
<                     sum++;
<                 }
<             }
---
>       }
>     }
>   } else if (direction == 3) {
>     for (let i = 0; i < current_token.length; i++) {
>       for (let j = 0; j < current_token.length; j++) {
>         if (gameMatrix[mod(h_token - i, 24)][mod(i_token + j + 1, 18)] > 1 && current_token[i][j] != 0) {
>           sum++;
268a271
>       }
270c273,274
<     return sum == 0;
---
>   }
>   return sum == 0;
274,279c278,283
<     if (color == 0) return;
<     push();
<     fill(colors[color]);
<     translate(cos(step * (i + 0)) * tetrisRadius, (h + 1) * (height_step + 1), sin(step * (i + 0)) * tetrisRadius);
<     box(20);
<     pop();
---
>   if (color == 0) return;
>   push();
>   fill(colors[color]);
>   translate(cos(step * (i + 0)) * tetrisRadius, (h + 1) * (height_step + 1), sin(step * (i + 0)) * tetrisRadius);
>   box(20);
>   pop();
284,288c288,292
<     if (current_order.length == 0) {
<         current_order = shuffle(tokens);
<     }
<     current_token = current_order.pop()
<     h_token = 17 + current_token.length;
---
>   if (current_order.length == 0) {
>     current_order = shuffle(tokens);
>   }
>   current_token = current_order.pop()
>   h_token = 17 + current_token.length;
293c297
<     cameraDistance += (event.delta / 10);
---
>   cameraDistance += (event.delta / 10);
297,303c301,307
<     if (keyCode == 81) {
<         rotate_token(true);
<     }
<     if (keyCode == 69) {
<         rotate_token(false);
<     }
< }
---
>   if (keyCode == 81) {
>     rotate_token(true);
>   }
>   if (keyCode == 69) {
>     rotate_token(false);
>   }
> }
\ No newline at end of file
