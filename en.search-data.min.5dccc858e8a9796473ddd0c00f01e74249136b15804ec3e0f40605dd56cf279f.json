[{"id":0,"href":"/Talleres/docs/Workshop/workshop_1/","title":"Workshop 1","section":"Workshop","content":" Statments # Study, implement and discuss possible applications of some known visual phenomena and optical illusions. Implement an image processing web app supporting different image kernels and supporting: Image histogram visualization. Different lightness (coloring brightness) tools. "},{"id":1,"href":"/Talleres/docs/Workshop/workshop_1/masking/","title":"Masking","section":"Workshop 1","content":" Masking # Image processing # Shortcuts # Key Action t toggle kernel Code # Image processing app\u0026rsquo;s code var stateR; var stateG; var stateB; var red_arr = new Array(256); var green_arr = new Array(256); var blue_arr = new Array(256); var showFilter = false; const filter = \\[ [-2, -1, 0], [-1, 1, 1], [0, 1, 2], ]; const filter2 = \\[ [-1, 0, 1], [-1, 0, 1], [-1, 0, 1], ]; var colors = new Array(3); var leftM = 30; var upM = 15; function preload() { img = loadImage(\u0026#34;/Talleres/sketches/taller1/assets/turquia.jpg\u0026#34;); } function getIndex(x, y) { return (x + y _ img.width) _ 4; } function setup() { createCanvas(img.width + 2 _ leftM, img.height _ 2 + 2 \\* upM); stateR = color(\u0026#39;rgba(255,0,0,0.1)\u0026#39;) stateG = color(\u0026#39;rgba(0,255,0,0.1)\u0026#39;) stateB = color(\u0026#39;rgba(0,0,255,0.1)\u0026#39;) for (let i = 0; i \u0026amp;lt; 256; i++) { red_arr[i] = green_arr[i] = blue_arr[i] = 0; } // img.filter(GRAY); loadPixels(); img.loadPixels(); filtered = createImage(img.width, img.height); filtered.loadPixels(); for (let i = 0; i \u0026amp;lt; img.width; i++) { for (let j = 0; j \u0026amp;lt; img.height; j++) { let idx = getIndex(i, j); let r = img.pixels[idx + 0]; let g = img.pixels[idx + 1]; let b = img.pixels[idx + 2]; let a = img.pixels[idx + 3]; red_arr[r]++; green_arr[g]++; blue_arr[b]++; //kernel let filteredPixel = convolute(i, j); filtered.pixels[idx + 0] = red(filteredPixel); filtered.pixels[idx + 1] = green(filteredPixel); filtered.pixels[idx + 2] = blue(filteredPixel); filtered.pixels[idx + 3] = alpha(filteredPixel); } } colors[0] = red_arr; colors[1] = green_arr; colors[2] = blue_arr; img.updatePixels(); filtered.updatePixels(); updatePixels(); strokeWeight(4); } function calculateHistogram(imagen) { stateR = color(\u0026#39;rgba(255,0,0,0.1)\u0026#39;) stateG = color(\u0026#39;rgba(0,255,0,0.1)\u0026#39;) stateB = color(\u0026#39;rgba(0,0,255,0.1)\u0026#39;) for (let i = 0; i \u0026amp;lt; 256; i++) { red_arr[i] = green_arr[i] = blue_arr[i] = 0; } // img.filter(GRAY); loadPixels(); imagen.loadPixels(); filtered.loadPixels(); for (let i = 0; i \u0026amp;lt; imagen.width; i++) { for (let j = 0; j \u0026amp;lt; imagen.height; j++) { let idx = getIndex(i, j); let r = imagen.pixels[idx + 0]; let g = imagen.pixels[idx + 1]; let b = imagen.pixels[idx + 2]; let a = imagen.pixels[idx + 3]; red_arr[r]++; green_arr[g]++; blue_arr[b]++; } } colors[0] = red_arr; colors[1] = green_arr; colors[2] = blue_arr; imagen.updatePixels(); updatePixels(); strokeWeight(4); } function mousePressed() { if (mouseX \u0026amp;lt; leftM || mouseX \u0026gt; leftM + 70) return stateR = color(\u0026#39;rgba(255,0,0,0.1)\u0026#39;) stateG = color(\u0026#39;rgba(0,255,0,0.1)\u0026#39;) stateB = color(\u0026#39;rgba(0,0,255,0.1)\u0026#39;) if (mouseY \u0026gt;= 2 _ upM + img.height \u0026amp;\u0026amp; mouseY \u0026amp;lt;= 2 _ upM + img.height + 40) { stateR = color(\u0026#39;rgba(255,0,0,1)\u0026#39;) } else if (mouseY \u0026gt;= 2 _ upM + img.height + 50 \u0026amp;\u0026amp; mouseY \u0026amp;lt;= 2 _ upM + img.height + 40 + 50) { stateG = color(\u0026#39;rgba(0,255,0,1)\u0026#39;) } else if (mouseY \u0026gt;= 2 _ upM + img.height + 100 \u0026amp;\u0026amp; mouseY \u0026amp;lt;= 2 _ upM + img.height + 40 + 100) { stateB = color(\u0026#39;rgba(0,0,255,1)\u0026#39;) } } function draw() { background(220); //image(img, leftM, upM); if (showFilter) image(filtered, leftM, upM); else image(img, leftM, upM); stroke(0); push(); fill(255, 0, 0); rect(leftM + 10, 2 _ upM + img.height, 70, 40); fill(0, 255, 0); rect(leftM + 10, 2 _ upM + img.height + 50, 70, 40); fill(0, 0, 255); rect(leftM + 10, 2 \\* upM + img.height + 100, 70, 40); pop(); push(); if (stateR.toString() == color(\u0026#39;rgba(255,0,0,1)\u0026#39;).toString()) { paint(stateG, colors[1]); paint(stateB, colors[2]); paint(stateR, colors[0]); } else if (stateG.toString() == color(\u0026#39;rgba(0,255,0,1)\u0026#39;).toString()) { paint(stateR, colors[0]); paint(stateB, colors[2]); paint(stateG, colors[1]); } else { paint(stateR, colors[0]); paint(stateG, colors[1]); paint(stateB, colors[2]); } pop(); graph(); } function graph() { push(); stroke(0); strokeWeight(1); fill(0); drawArrow(createVector(leftM, 2 _ img.height), createVector(leftM + img.width, 2 _ img.height), \u0026#39;x\u0026#39;); drawArrow(createVector(leftM, 2 \\* img.height), createVector(leftM, img.height + upM), \u0026#39;y\u0026#39;); textAlign(CENTER); textSize(20); text(\u0026#39;Valores del color (0 - 255) \u0026#39;, leftM + img.width / 2, 2 _ img.height + 2 _ upM); let angle2 = radians(270); translate(leftM / 2, (3 / 2) \\* img.height); rotate(angle2); // Draw the letter to the screen text(\u0026#34;Frecuencias\u0026#34;, 0, 0); pop(); } function paint(state, array) { push(); stroke(state); for (let i = 1; i \u0026amp;lt; 256; i++) { xPos = map(i, 0, 256, leftM, leftM + img.width) xPrev = map(i - 1, 0, 256, leftM, leftM + img.width) yPos = map(array[i], 0, max(array), 2 _ img.height, img.height + 25) yPrev = map(array[i - 1], 0, max(array), 2 _ img.height, img.height + 25) line(xPrev, yPrev, xPos, yPos) line(xPos, 2 \\* img.height, xPos, yPos) } pop(); } function drawArrow(base, vec, axis) { push(); stroke(0); strokeWeight(3); fill(0); line(base.x, base.y, vec.x, vec.y); let arrowSize = 7; if (axis == \u0026#39;x\u0026#39;) { vec.x -= 7; triangle(vec.x, vec.y + arrowSize / 2, vec.x, vec.y - arrowSize / 2, vec.x + arrowSize, vec.y); } else { vec.y += 7; triangle(vec.x + arrowSize / 2, vec.y, vec.x - arrowSize / 2, vec.y, vec.x, vec.y - arrowSize); } pop(); } function convolute(x, y) { let sumR = 0; let sumG = 0; let sumB = 0; for (let i = -1; i \u0026amp;lt;= 1; i++) { for (let j = -1; j \u0026amp;lt;= 1; j++) { let pix = getIndex(x + i, y + j); let factor = filter[j + 1][i + 1]; sumR += img.pixels[pix + 0] * factor; sumG += img.pixels[pix + 1] * factor; sumB += img.pixels[pix + 2] * factor; } } return color( sumR, sumG, sumB ); } function keyPressed() { if (keyCode === 84) { showFilter = !showFilter if (showFilter) calculateHistogram(filtered); else calculateHistogram(img); } } Image Kernels # Problem Statement # Implement an image processing web app supporting different image kernels.\nBackground # The use of Kernels also known as convolution matrices or masks is invaluable to image processing. Techniques such as blurring, edge detection, and sharpening all rely on kernels - small matrices of numbers to be applied across an image in order to process the image as a whole.\nThey\u0026rsquo;re also used in machine learning for \u0026lsquo;feature extraction\u0026rsquo;, a technique for determining the most important portions of an image. In this context the process is referred to more generally as \u0026ldquo;convolution\u0026rdquo; (see: convolutional neural networks.)\nResults # We implemented the convolutional layer by defining a 3x3 matrix in which the filter was defined, then we just iterated through each pixel in the image and calculated a new filtered pixel by adding each of its neighbors weighted with the kernel matrix. Edge pixels were ignored as they don\u0026rsquo;t have the 8 corresponding neighbors.\nConclusions \u0026amp; Future Work # This method may not be the most efficient to implement this kind of filtering process, using parallel computing may be faster. But as an educative example it\u0026rsquo;s pretty effective and illustrative. We use this kind of filters in our daily lives wihtout even knowing it (until we learned about it), it\u0026rsquo;s used in processing image software (such as photoshop or gimp) and the social media networks we often use. As a future work, it\u0026rsquo;d be interesting to know how to generate (or approximate) a kernel matrix to achieve a desired filter, also to learn how to implement this by using parallel computing and implement some video filtering.\nImage histogram # Problem Statement # Implement Image histogram visualization.\nBackground # The histogram of a digital image depicts how the intensities of its pixels are distributed. It is the discrete function h such that\n\\[ h(x) = n_i \\] where \\(n_i \\) is the number of pixels with intensity \\(i \\) .\nHistograms are used to quickly analyze the composition of an image, it can be used in RGB composition, gray scale, brightness or the system that best suits our needs.\nThe pixel values are processed individually, an aggregate is made for each value and the searched histogram is plotted\nResults # As we can see, the histogram of an image is made from its RGB color scalar, for this we analyze each pixel and see how much it contains of each value, which is a value between 0 and 255, then we make the graph by mapping the respective values that allow highlighting the composition of the image.\nOn the x axis we have the represents the variations of the tone, and on the y axis the quantities that appear in the pixels of the image\nConclusions \u0026amp; Future Work # Knowing how to create and read an image histogram is a very powerful tool that allows people who work with graphics and everything related to visual computing to quickly analyze an image, it is recommended to have a clear base with what type of color composition according to our objective, so that our graphs agree with the applications of the project. It\u0026rsquo;s also very useful for photographers which use this histograms to know if a photo they took is well exposed or not, by checking if the vast amount of color is either in the left zone of the histogram (meaning the image is underexposed ) or to the right zone (meaning it\u0026rsquo;s overexposed)\nLigthness # Problem Statement # Implement a web app that allows the user to change the lightness of an image.\nBackground # The lightness of an image is the average of the RGB values of each pixel. The lightness of an image can be changed by adding a constant value to each pixel. This constant value can be positive or negative.\nThereś also other ways to modify the brightness of an image, by modifying some parameters depending on the image color space. For example, in the HSL color space, the lightness can be modified by changing the L parameter.\nFor this, we used a sample image, where we can reduce or increase the image brightness, and depending on whic color mode the image is, we can do a biyection to RGB and get the new image, modifying the parameters we need.\n| Down Arrow | Decrease Brightness |\nDemo # Shortcuts # Key Action Up Arrow Increase Brightness Down Arrow Decrease Brightness Left Arrow Decrease Brightness (more) Right Arrow Increase Brightness (more) Code # Image brightness app\u0026rsquo;s code let img; let brightness_reduction = 0; function calculate_hue(r_prime, g_prime, b_prime) { // Geometric method let c_max = max(r_prime, g_prime, b_prime); // max of r\u0026#39;, g\u0026#39;, b\u0026#39; let c_min = min(r_prime, g_prime, b_prime); // min of r\u0026#39;, g\u0026#39;, b\u0026#39; let delta = c_max - c_min; // delta rgb let h = 0; let s = 0; if (delta == 0) { h = 0; // Can be any color } else if (c_max == r_prime) { h = 60 _ (((g_prime - b_prime) / delta) % 6); } else if (c_max == g_prime) { h = 60 _ ((b_prime - r_prime) / delta + 2); } else if (c_max == b_prime) { h = 60 \\* ((r_prime - g_prime) / delta + 4); } if (c_max) { s = delta / c_max; } return h; } function calculate_saturation(r_prime, g_prime, b_prime) { // Distance from center to max let c_max = max(r_prime, g_prime, b_prime); // max of r\u0026#39;, g\u0026#39;, b\u0026#39; let c_min = min(r_prime, g_prime, b_prime); // min of r\u0026#39;, g\u0026#39;, b\u0026#39; let delta = c_max - c_min; // delta rgb let s = 0; if (c_max) { s = 1 - c_min / c_max; } return s \\* 100; } function calculate_value(r_prime, g_prime, b_prime) { // Height of the cilinder let c_max = max(r_prime, g_prime, b_prime); // max of r\u0026#39;, g\u0026#39;, b\u0026#39; let v = c_max; return v \\* 100; } function calculate_hsl_saturation(r_prime, g_prime, b_prime) { // Distance from center to max let c_max = max(r_prime, g_prime, b_prime); // max of r\u0026#39;, g\u0026#39;, b\u0026#39; let c_min = min(r_prime, g_prime, b_prime); // min of r\u0026#39;, g\u0026#39;, b\u0026#39; let delta = c_max - c_min; // delta rgb let s = 0; if (calculate_lightness(r_prime, g_prime, b_prime) != 0 \u0026amp;\u0026amp; calculate_lightness(r_prime, g_prime, b_prime) != 100) { s = delta / (1 - abs(2 \\* c_max - 1)); } return s \\* 100; } function calculate_lightness(r_prime, g_prime, b_prime) { let c_max = max(r_prime, g_prime, b_prime); // max of r\u0026#39;, g\u0026#39;, b\u0026#39; let c_min = min(r_prime, g_prime, b_prime); // min of r\u0026#39;, g\u0026#39;, b\u0026#39; let l = (c_max + c_min) / 2; return l \\* 100; } function get_pixel_position(x, y, width) { return (x + y _ width) _ 4; } function get_pixel_color(x, y, width) { let xy = get_pixel_position(x, y, width); return \\[ img.pixels[xy], img.pixels[xy + 1], img.pixels[xy + 2], img.pixels[xy + 3], ]; } function set_hsb(colour) { let r_prime = colour[0] / 255; let g_prime = colour[1] / 255; let b_prime = colour[2] / 255; let h = calculate_hue(r_prime, g_prime, b_prime); let s = calculate_saturation(r_prime, g_prime, b_prime); let b = calculate_value(r_prime, g_prime, b_prime); return [h, s, b]; } function set_hsl(colour) { let r_prime = colour[0] / 255; let g_prime = colour[1] / 255; let b_prime = colour[2] / 255; let h = calculate_hue(r_prime, g_prime, b_prime); let s = calculate_hsl_saturation(r_prime, g_prime, b_prime); let l = calculate_lightness(r_prime, g_prime, b_prime); let hsl = [h, s, l]; return hsl; } function preload() { img = loadImage(\u0026#34;\u0026lt;https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcS1bE-X0pmMMWQOaHNzX4mUDGHCgsESpHyqD8pYxizqaENqaemB\u0026#34;)\u0026gt;; img.loadPixels(); } function setup() { createCanvas(600, 520); background(255); } function keyPressed() { if (keyCode === 39) { // brightness_reduction -= 5; } else if (keyCode === 37) { // brightness_reduction += 5; } else if (keyCode === 38) { // brightness_reduction -= 1; } else if (keyCode === 40) { // brightness_reduction += 1; } if (brightness_reduction \u0026gt; 100) { brightness_reduction = 100; } else if (brightness_reduction \u0026amp;lt; -100) { brightness_reduction = -100; } } function draw() { // put drawing code here // Change the image brightness in RGB mode colorMode(RGB); background(255); text(\u0026#34;Brightness reduction: \u0026#34; + brightness_reduction, 10, 510); image(img, 0, 20); text(\u0026#34;Original Image\u0026#34;, img.width / 3, 10); img.loadPixels(); let changed_img = img.get(); changed_img.loadPixels(); let rgb_brightness_reduction = (256 \\* brightness_reduction) / 100; for (let i = 0; i \u0026amp;lt; img.width; i++) { for (let j = 0; j \u0026amp;lt; img.height; j++) { let new_color = get_pixel_color(i, j, img.width); new_color[0] = new_color[0] - rgb_brightness_reduction; new_color[1] = new_color[1] - rgb_brightness_reduction; new_color[2] = new_color[2] - rgb_brightness_reduction; changed_img.set(i, j, color(new_color)); } } changed_img.updatePixels(); image(changed_img, 250, 20); text(\u0026#34;Changed Image (RGB)\u0026#34;, 250 + img.width / 4, 10); // Change image brightness with HSB color mode colorMode(HSB); changed_img1 = img.get(); changed_img1.loadPixels(); for (let i = 0; i \u0026amp;lt; img.width; i++) { for (let j = 0; j \u0026amp;lt; img.height; j++) { let new_hsb_color = set_hsb(get_pixel_color(i, j, img.width)); new_hsb_color[2] = new_hsb_color[2] - (brightness_reduction ); changed_img1.set(i, j, color(new_hsb_color)); } } changed_img1.updatePixels(); image(changed_img1, 250, 270); text(\u0026#34;Changed Image (HSB)\u0026#34;, 250 + img.width / 4, 260); // Change image brightness with HSL color mode colorMode(HSL); changed_img2 = img.get(); changed_img2.loadPixels(); for (let i = 0; i \u0026amp;lt; img.width; i++) { for (let j = 0; j \u0026amp;lt; img.height; j++) { let new_hsl_color = set_hsl(get_pixel_color(i, j, img.width)); new_hsl_color[2] = new_hsl_color[2] - (brightness_reduction ); changed_img2.set(i, j, color(new_hsl_color)); } } changed_img2.updatePixels(); image(changed_img2, 0, 270); text(\u0026#34;Changed Image (HSL)\u0026#34;, img.width / 3, 260); } } I am trying to change the brightness of an image using the HSB and HSL color modes. I am using the formula from here: https://www.rapidtables.com/convert/color/rgb-to-hsl.html\nExpected Behavior # The brightness of the image should be reduced by x% in all the three modes.\nConclusions and Future Work # The brightness of the image can be reduced by x% in all the three modes. The HSB mode is the most accurate in reducing the brightness of the image. The HSL mode is the least accurate in reducing the brightness of the image. The RGB mode is in between the two.\n"},{"id":2,"href":"/Talleres/docs/Workshop/workshop_1/visual_ilussion/","title":"Visual Ilussion","section":"Workshop 1","content":" Visual Illusions # Problem statement # Study, implement and discuss possible applications of some known visual phenomena and optical illusions.\nBackground # Visual illusions are a fascinating topic. They are a great way to learn about the human visual system and how it works. They are also a great way to learn about the limitations of the human visual system. In this workshop we will study some of the most famous visual illusions and try to understand how they work. We will also try to understand how they can be used to create interesting visual effects.\nImplementation # In this workshop we will implement some of the most famous visual illusions using the p5.js library.\nFrisens Lazy Shadow Frisén’s Lazy Shadow # Code # Frisén’s Lazy Shadow Code let angulo; let speed; let rot; let stopButton; let startButton; let speedSlider; let rotSlider; let lightBackground; function stop() { speedSlider.value(0); } function start() { speedSlider.value(0.05); } function preload() { img = loadImage(\u0026#39;/Talleres/sketches/taller1/assets/plus.png\u0026#39;); } function setup() { createCanvas(500, 500); noStroke(); startButton = createButton(\u0026#39;Start\u0026#39;); startButton.position(0, 0); startButton.size(100, 30); startButton.mousePressed(start); stopButton = createButton(\u0026#39;Stop\u0026#39;); stopButton.position(0, 35); stopButton.size(100, 30); stopButton.mousePressed(stop); speedSlider = createSlider(0, 0.5, 0. Jastrow Illusion Jastrow Illusion # Code # Jastrow Illusion Code let img; let xcord; let ycord; function preload() { img = loadImage(\u0026#39;/Talleres/sketches/taller1/assets/track1.png\u0026#39;); } function setup() { createCanvas(500, 500); noStroke(); xcord = 0; ycord = 0; } function draw() { background(150); image(img, 50+xcord, 50+ycord, 300, 100); image(img, 90-xcord, 150-ycord, 300, 100); if (xcord \u0026gt;= 40) { sleep(2000).then( () =\u0026gt; { xcord = 0; ycord = 0; } ) }else{ xcord = xcord + 1/5; ycord = ycord + (100/40)/5; } } function sleep(millisecondsDuration){ return new Promise((resolve) =\u0026gt; { setTimeout(resolve, millisecondsDuration); }) } Visualization # Background # Jastrow\u0026rsquo;s optical illusion was discovered in 1889 by the American psychologist Joseph Jastrow. Kinegram Scanimation Kinegram (“Scanimation”) # Code # Kinegram (Scanimation) Pacman Code let xPosition = 900 ; let blue_rect; let yellow_rect; let sum = -1 function setup() { createCanvas(900, 300); bg = loadImage(\u0026#39;/Talleres/sketches/taller1/assets/pacman.png\u0026#39;); } function draw() { image(bg, 0, 0); if ( xPosition \u0026gt; width ){ sum = -1 let ms = millis() + 5000 while ( millis ( ) \u0026lt; ms ){ } } if ( xPosition \u0026lt; 0 ){ let ms = millis() + 5000 while ( millis ( ) \u0026lt; ms ){ } sum = 1 } xPosition = xPosition+ sum for (let i = xPosition; i \u0026lt; width ; i+=17) { let c = color(0, 0, 0); fill(c); noStroke(); rect(i, 0, 15, 247); } let ms = millis() + 40 while ( millis ( ) \u0026lt; ms ){ } } Kinegram (Scanimation) Circle Code let img; let w, h; let sum = -1 let xPosition; function preload() { img = loadImage(\u0026#39;/Talleres/sketches/taller1/assets/circle. Stepping Feet Motion Illusion “Stepping feet” Motion Illusion # Code # Stepping feet Motion Illusion Code let xPosition = 0 ; let blue_rect; let yellow_rect; let sum = 1 function setup() { createCanvas(600, 400); } function draw() { background(230); if (keyIsPressed === false) { for (let i = 0; i \u0026lt; width ; i+=20) { let c = color(0, 0, 0); fill(c); noStroke(); rect(i, 0, 10, 720); } } xPosition = xPosition+ sum if ( xPosition + 40 \u0026gt; 600 ){ sum = -1 } if ( xPosition \u0026lt; 0 ){ sum = 1 } c = color(0, 0, 190); fill(c); noStroke(); blue_rect=rect(xPosition, 170, 40, 30); c = color(255, 255, 0); fill(c); noStroke(); yellow_rect=rect(xPosition, 230, 40, 30); let ms = millis() + 50 while ( millis ( ) \u0026lt; ms ){ } } Visualization # Background # The \u0026ldquo;Stepping feet” Motion Illusion is a visual illusion. "},{"id":3,"href":"/Talleres/docs/Workshop/workshop_1/visual_ilussion/frisensLazyShadow/","title":"Frisens Lazy Shadow","section":"Visual Ilussion","content":" Frisén’s Lazy Shadow # Code # Frisén’s Lazy Shadow Code let angulo; let speed; let rot; let stopButton; let startButton; let speedSlider; let rotSlider; let lightBackground; function stop() { speedSlider.value(0); } function start() { speedSlider.value(0.05); } function preload() { img = loadImage(\u0026#39;/Talleres/sketches/taller1/assets/plus.png\u0026#39;); } function setup() { createCanvas(500, 500); noStroke(); startButton = createButton(\u0026#39;Start\u0026#39;); startButton.position(0, 0); startButton.size(100, 30); startButton.mousePressed(start); stopButton = createButton(\u0026#39;Stop\u0026#39;); stopButton.position(0, 35); stopButton.size(100, 30); stopButton.mousePressed(stop); speedSlider = createSlider(0, 0.5, 0.1, 0.01); speedSlider.position(0, 85); speedSlider.size(100, 30); rotSlider = createSlider(-0.1, 0.1, 0, 0.01); rotSlider.position(0, 130); rotSlider.size(100, 30); lightBackground = createCheckbox(\u0026#39;Light Background\u0026#39;, false); lightBackground.position(0, 180); lightBackground.style(\u0026#39;color\u0026#39;, \u0026#39;#fff\u0026#39;); lightBackground.size(150, 30); angulo = 0; rectMode(CENTER); } function draw() { background(0); if (lightBackground.checked()) { fill(\u0026#34;yellow\u0026#34;); circle(250, 250, 300); } speed = speedSlider.value(); rot = rotSlider.value(); angulo = angulo + speed % TWO_PI; translate(width / 2, height / 2); rotate(angulo); fill(0,0,255); rect(0, 0, 130, 130); rotate(rot); fill(255); rect(0, 0, 110, 110); fill(200,200,200); rotate(-angulo-rot); text(\u0026#34;Speed\u0026#34;, -225, -170); text(\u0026#34;Compensate\u0026#34;, -240, -125); rotate(PI/4); image(img, -3, -3, 6, 6); } Visualization # Background # The Frisén’s Lazy Shadow illusion is a visual illusion that occurs when a shadow is cast on a surface that is not parallel to the observer. It is named after the Swedish psychologist Carl Gustav Frisén.\nThe illusion occurs because the observer’s brain tries to adjust the shadow to the surface. The observer’s brain expects the shadow to be parallel to the surface, but the shadow is not parallel to the surface. The observer’s brain tries to adjust the shadow to the surface, and the result is the illusion.\nResults # In this case we use a white scuare to simulate the surface and a blue square to simulate the shadow. The shadow is not parallel to the surface(it can be modify using the Compensate slider), but the observer’s brain tries to adjust the shadow to the surface(consecuence of the speed), and the result is the illusion.\nTo see the the descompensation of the shadow, you can use the button stop or check the box \u0026ldquo;Light Background\u0026rdquo;.\nConclusions # Is very interesting the way that the brain tries to adjust the shadow to the surface, and the result is the illusion. The speed of the adjustment is very important, because if the speed is very slow, the observer’s brain can’t adjust the shadow to the surface, and the result is not the illusion.\nOther important fact is that when the movement is suddenly stopped you can see for a moment that the scuares moves in the opposite direction, and then the brain adjust the shadow to the surface, and the result is the illusion.\n"},{"id":4,"href":"/Talleres/docs/Workshop/workshop_1/visual_ilussion/jastrowIllusion/","title":"Jastrow Illusion","section":"Visual Ilussion","content":" Jastrow Illusion # Code # Jastrow Illusion Code let img; let xcord; let ycord; function preload() { img = loadImage(\u0026#39;/Talleres/sketches/taller1/assets/track1.png\u0026#39;); } function setup() { createCanvas(500, 500); noStroke(); xcord = 0; ycord = 0; } function draw() { background(150); image(img, 50+xcord, 50+ycord, 300, 100); image(img, 90-xcord, 150-ycord, 300, 100); if (xcord \u0026gt;= 40) { sleep(2000).then( () =\u0026gt; { xcord = 0; ycord = 0; } ) }else{ xcord = xcord + 1/5; ycord = ycord + (100/40)/5; } } function sleep(millisecondsDuration){ return new Promise((resolve) =\u0026gt; { setTimeout(resolve, millisecondsDuration); }) } Visualization # Background # Jastrow\u0026rsquo;s optical illusion was discovered in 1889 by the American psychologist Joseph Jastrow. This illusion misleads us into believing that one of the figures presented is larger than the other, when in fact both are the same size.\nThe base of the illusion is put the second figure\u0026rsquo;s top right corner aligned whit the first figure\u0026rsquo;s bottom right corner, after that the observer\u0026rsquo;s brain tries to adjust the second figure to the first figure, and the result is the illusion making it look like the second figure is larger than the first figure when in fact both are the same size.\nResults # In this case we use two puzzle pieces to simulate the figures. The second figure\u0026rsquo;s top right corner is aligned whit the first figure\u0026rsquo;s bottom right corner, and after a time the figures moves in diagonal direction showing that both are the same size.\nOf this way is shown how the relative position of the second figure to the first figure is that creates the illusion that the second figure is apparently larger than the first figure.\nConclusions # The mos important thing is how the breain tries to make sense at the relative position of the second figure to the first figure, and make as think that the second figure is apparently larger than the first figure.\nThis is a very interesting illusion, because it is very simple, but it is very effective. It show as how our brain works, and how it tries to make sense at the world around us and how it sometimes tricks us.\n"},{"id":5,"href":"/Talleres/docs/Workshop/workshop_1/visual_ilussion/kinegramScanimation/","title":"Kinegram Scanimation","section":"Visual Ilussion","content":" Kinegram (“Scanimation”) # Code # Kinegram (Scanimation) Pacman Code let xPosition = 900 ; let blue_rect; let yellow_rect; let sum = -1 function setup() { createCanvas(900, 300); bg = loadImage(\u0026#39;/Talleres/sketches/taller1/assets/pacman.png\u0026#39;); } function draw() { image(bg, 0, 0); if ( xPosition \u0026gt; width ){ sum = -1 let ms = millis() + 5000 while ( millis ( ) \u0026lt; ms ){ } } if ( xPosition \u0026lt; 0 ){ let ms = millis() + 5000 while ( millis ( ) \u0026lt; ms ){ } sum = 1 } xPosition = xPosition+ sum for (let i = xPosition; i \u0026lt; width ; i+=17) { let c = color(0, 0, 0); fill(c); noStroke(); rect(i, 0, 15, 247); } let ms = millis() + 40 while ( millis ( ) \u0026lt; ms ){ } } Kinegram (Scanimation) Circle Code let img; let w, h; let sum = -1 let xPosition; function preload() { img = loadImage(\u0026#39;/Talleres/sketches/taller1/assets/circle.png\u0026#39;) w = img.width; h = img.height; angleMode(DEGREES); } function setup() { w = img.width; h = img.height; xPosition = w ; createCanvas(w, h); } function rotateImage ( change_image , d ,deg ){ rotate ( deg ) ; let change_img = img.get(); change_img.loadPixels(); for (let i = 0; i \u0026lt; w; i++) { for (let j = 0; j \u0026lt; h; j++) { let pix = (i + j * change_img.width) * 4; if ( (i % 3) == 1 ){ if ( change_img.pixels[pix + 0] \u0026gt; 200 \u0026amp;\u0026amp; change_img.pixels[pix + 1] \u0026gt; 200){ continue; } if ( change_img.pixels[pix + 0] \u0026gt; 200){ change_img.pixels[pix + 0] = 255; change_img.pixels[pix + 1] = 0; change_img.pixels[pix + 2] = 0; change_img.pixels[pix + 3] = 255; pix = ( ( i + 1 ) + j * change_img.width) * 4; change_img.pixels[pix + 0] = 0; change_img.pixels[pix + 1] = 255; change_img.pixels[pix + 2] = 0; change_img.pixels[pix + 3] = 255; pix = ( ( i + 2 ) + j * change_img.width) * 4; change_img.pixels[pix + 0] = 0; change_img.pixels[pix + 1] = 0; change_img.pixels[pix + 2] = 255; change_img.pixels[pix + 3] = 255; } else if ( change_img.pixels[pix + 1] \u0026gt; 200){ change_img.pixels[pix + 0] = 0; change_img.pixels[pix + 1] = 255; change_img.pixels[pix + 2] = 0; change_img.pixels[pix + 3] = 255; pix = ( ( i + 1 ) + j * change_img.width) * 4; change_img.pixels[pix + 0] = 0; change_img.pixels[pix + 1] = 0; change_img.pixels[pix + 2] = 255; change_img.pixels[pix + 3] = 255; pix = ( ( i + 2 ) + j * change_img.width) * 4; change_img.pixels[pix + 0] = 255; change_img.pixels[pix + 1] = 0; change_img.pixels[pix + 2] = 0; change_img.pixels[pix + 3] = 255; } else if ( change_img.pixels[pix + 2] \u0026gt; 200){ change_img.pixels[pix + 0] = 0; change_img.pixels[pix + 1] = 0; change_img.pixels[pix + 2] = 255; change_img.pixels[pix + 3] = 255; pix = ( ( i + 1 ) + j * change_img.width) * 4; change_img.pixels[pix + 0] = 255; change_img.pixels[pix + 1] = 0; change_img.pixels[pix + 2] = 0; change_img.pixels[pix + 3] = 255; pix = ( ( i + 2 ) + j * change_img.width) * 4; change_img.pixels[pix + 0] = 0; change_img.pixels[pix + 1] = 255; change_img.pixels[pix + 2] = 0; change_img.pixels[pix + 3] = 255; } } } } change_img.updatePixels(); image(change_img , 0, 0); } function draw() { img.loadPixels(); let change_img = img.get ( ) rotateImage ( change_img , 0 , 0) ; if ( xPosition \u0026gt; img.width ){ sum = -1 let ms = millis() + 5000 while ( millis ( ) \u0026lt; ms ){ } } if ( xPosition \u0026lt; 0 ){ let ms = millis() + 5000 while ( millis ( ) \u0026lt; ms ){ } sum = 1 } xPosition = xPosition+ sum for (let i = xPosition; i \u0026lt; width ; i+=6 ) { let c = color(0, 0, 0); fill(c); noStroke(); rect(i, 0, 5, h); } let ms = millis() + 250 while ( millis ( ) \u0026lt; ms ){ } } Visualization # Background # The Kinegram (“Scanimation”) is a visual illusion that was created in the late 1890s. This illusion consists of placing an image and then moving a black grid with narrow slits from side to side, making it appear as if the image is moving.\nFor the illusion to work it is required to create frames of the image to move, and then make assumptions of these frames, then when the grid passes the empty spaces will remain at the same frame and when you keep moving the image will be moving by frames and giving the illusion that the image is moving.\nResults # The first illusion is an image of a pacman, it makes it look like he is eating the balls and the balls are moving towards pacman, for both illusions the grid moves from right to left and when it reaches the right edge the grid starts to move back.\nThe second illusion is a kinegram created by us, this consists of a circle in which the colors are exchanged, in total consists of only 3 frames and the grid moves in the same way as the first illusion, the following shows the three frames created.\nConclusions # It is very interesting to see how with just a grid you can create images with movement. It is important to keep in mind that depending on the number of frames we have and the width we have given to our frame so will make our grid. The more frames we have, the wider each black part of the grid will be. The wider the frames the wider the white part of the grid will be. Another thing to keep in mind is that the width of the frames must be the same.\nIt is important that the movement is cyclical, so that there are no jumps in the sequence we want to show.\n"},{"id":6,"href":"/Talleres/docs/Workshop/workshop_1/visual_ilussion/steppingFeetMotionIllusion/","title":"Stepping Feet Motion Illusion","section":"Visual Ilussion","content":" “Stepping feet” Motion Illusion # Code # Stepping feet Motion Illusion Code let xPosition = 0 ; let blue_rect; let yellow_rect; let sum = 1 function setup() { createCanvas(600, 400); } function draw() { background(230); if (keyIsPressed === false) { for (let i = 0; i \u0026lt; width ; i+=20) { let c = color(0, 0, 0); fill(c); noStroke(); rect(i, 0, 10, 720); } } xPosition = xPosition+ sum if ( xPosition + 40 \u0026gt; 600 ){ sum = -1 } if ( xPosition \u0026lt; 0 ){ sum = 1 } c = color(0, 0, 190); fill(c); noStroke(); blue_rect=rect(xPosition, 170, 40, 30); c = color(255, 255, 0); fill(c); noStroke(); yellow_rect=rect(xPosition, 230, 40, 30); let ms = millis() + 50 while ( millis ( ) \u0026lt; ms ){ } } Visualization # Background # The \u0026ldquo;Stepping feet” Motion Illusion is a visual illusion. This illusion makes it seem that objects move fast or slow depending on background but what happens is the objects move a constant velocity. The first described of the illusion is by Stuart Anstis.\nFor the illusion to work, the luminance of the objects have to be different, for example the red and blue. Further the background also have to be different luminance, the best example of background is black and white. Because of the contrast of the objects with the background it is perceived that objects move fast or slow.\nResults # In this case we use the background line black and white interspersed. And the colors square is yellow and blue, the objects move from left to right and when it reaches the right edge the square begin to return to the left edge.\nTo see the objects without the background you can press any key.\nConclusions # Is very interesting see that luminance of the objects and the contrast with the background affects the perception of the movement. It\u0026rsquo;s very important to add that the width of the square and the background affect the illusion. For example, if the width from separation of the color black in very short the illusion don\u0026rsquo;t work,this is because there is very little time in the contrast when it passes through the white color.\n"},{"id":7,"href":"/Talleres/docs/Workshop/workshop_2/","title":"Workshop 2","section":"Workshop","content":" Statments # Implement in software any of the above visualizations: primitive rasterization, color shading, z-depth, texture-mapping (as illustrated above) and/or anti-aliasing (requires a bit of research).\nImplement a 3d webgl application. The p5.treegl or any other libraries may be used.\n"},{"id":8,"href":"/Talleres/docs/Workshop/workshop_2/practice/","title":"Practice","section":"Workshop 2","content":" Practice Rendering # Problem statement # Implement in software any of the above visualizations: primitive rasterization, color shading, z-depth, texture-mapping (as illustrated above) and/or anti-aliasing (requires a bit of research).\nPrimitive Rasterization # Rasterization consists of taking an image in vector graphics format and converting it into a raster image, this means a series of pixels, points or lines, which when displayed together create the image that was represented through vector graphics.\nFor this case we are going to make a rasterization of a triangle, then the first thing we must do is to know which pixels are contained within the triangle, for this case we use the edge function that is defined as follows:\nWhen the equation gives us less than zero, it means that the point is on the left side of the line, when it gives us greater it means that it is on the right side of the line and when it is equal to 0 it means that the point is exactly on the line.\nWe do this for each line of the triangle, and we verify that the results give us the same sign, it is important to clarify that the lines are running clockwise to the hands of the clock. Below is an example where pressing any key shows a different triangle.\nPrimitive Rasterization let a1,a2,b1,b2,c1,c2 function randomLine ( ){ a1 = int ( random(0, 17) ) * 25 ; a2 = int ( random(0, 17) ) * 25 ; b1 = int ( random(0, 17) ) * 25 ; b2 = int ( random(0, 17) ) * 25 ; c1 = int ( random(0, 17) ) * 25 ; c2 = int ( random(0, 17) ) * 25 ; } function setup() { createCanvas(400, 400); randomLine ( ) } function keyPressed() { randomLine(); } function draw() { background ( 0 ) for ( let x = 12.5 ; x \u0026lt;= 400 ; x += 25 ){ for ( let y = 12.5 ; y \u0026lt;= 400 ; y += 25 ){ let aux1 = ( ( x - a1 ) * ( b2 - a2 ) ) - ( ( y - a2 ) * ( b1 - a1 ) ) let aux2 = ( ( x - b1 ) * ( c2 - b2 ) ) - ( ( y - b2 ) * ( c1 - b1 ) ) let aux3 = ( ( x - c1 ) * ( a2 - c2 ) ) - ( ( y - c2 ) * ( a1 - c1 ) ) if ( ( aux1 \u0026lt;= 0 \u0026amp;\u0026amp; aux2 \u0026lt;= 0 \u0026amp;\u0026amp; aux3 \u0026lt;= 0 ) || ( aux1 \u0026gt;= 0 \u0026amp;\u0026amp; aux2 \u0026gt;= 0 \u0026amp;\u0026amp; aux3 \u0026gt;= 0 ) ){ let c = color(255, 0 , 128); fill(c); stroke ( c ) rect ( x - 12.5 , y - 12.5 , 25, 25 ) } } } for ( let i = 25 ; i \u0026lt;= 400 ; i += 25 ){ let c = color(0, 255, 0); fill(c); stroke(c); line ( i , 0 , i , 400 ) line ( 0 , i , 400 , i ) } let c = color(0, 0 , 255); fill(c); stroke ( c ) line( a1 , a2 , b1 , b2 ); line( b1 , b2 , c1 , c2 ); line( c1 , c2 , a1 , a2 ); } Z-Buffer # A z-buffer is a type of data buffer in which information about the depth of objects in 3D space from a particular perspective is stored. This helps to ensure that the correct polygons hide polygons that are further back.\nIt consists mainly of when you want to add a new element, it is compared pixel by pixel, and checks the buffer that currently has, if the depth is further away nothing is done, if it is greater the pixel of the element is added and the buffer is updated to the new depth.\nBelow is an example, you can press any key to change the location of the objects, additionally you can press the \u0026lsquo;z\u0026rsquo; key to see the buffer, in this case the lighter it is the closer the object is.\nThe Z-Buffer is widely used in video games and is mainly used in graphics cards because it is very easy and quite effective to parallelize it.\n"},{"id":9,"href":"/Talleres/docs/Workshop/workshop_2/rasterization/colorShading/","title":"Color Shading","section":"Rasterization","content":" Color shading # Code # Color shading Code const ROWS = 20; const COLS = 20; const LEN = 20; let quadrille; let v0y, v0x, v1y, v1x, v2y, v2x; let cp0, cp1, cp2; let p0 = [255, 0, 0, 7, 4], p1 = [0, 255, 0, -1, -10], p2 = [0, 0, 255, 5, 8]; function setup() { createCanvas(400, 440); quadrille = createQuadrille(20, 20); quadrille.colorize(\u0026#34;black\u0026#34;); keyPressed(); cp0 = createColorPicker(\u0026#34;red\u0026#34;); cp0.position(20, 415); cp0.input(setColors); cp1 = createColorPicker(\u0026#34;green\u0026#34;); cp1.position(120, 415); cp1.input(setColors); cp2 = createColorPicker(\u0026#34;blue\u0026#34;); cp2.position(220, 415); cp2.input(setColors); } function draw() { background(\u0026#34;black\u0026#34;); drawQuadrille(quadrille, { cellLength: LEN, outline: \u0026#34;green\u0026#34;, board: true, }); drawTriangle(); } function setColors() { p0[0] = red(cp0.color()); p0[1] = green(cp0.color()); p0[2] = blue(cp0.color()); p1[0] = red(cp1.color()); p1[1] = green(cp1.color()); p1[2] = blue(cp1.color()); p2[0] = red(cp2.color()); p2[1] = green(cp2.color()); p2[2] = blue(cp2.color()); showTringle(); } function drawTriangle() { push(); stroke(\u0026#34;cyan\u0026#34;); strokeWeight(3); noFill(); triangle( v0x * LEN + LEN / 2, v0y * LEN + LEN / 2, v1x * LEN + LEN / 2, v1y * LEN + LEN / 2, v2x * LEN + LEN / 2, v2y * LEN + LEN / 2 ); pop(); } function keyPressed() { randomizeTriangle(); showTringle(); } function showTringle() { quadrille.clear(); quadrille.rasterizeTriangle( v0y, v0x, v1y, v1x, v2y, v2x, colorize_shader, p0, p1, p2 ); } function colorize_shader({ pattern: mixin }) { let rgb = mixin.slice(0, 3); console.log(mixin.slice(3)); return color(rgb); } function randomizeTriangle() { v0x = int(random(0, COLS)); v0y = int(random(0, ROWS)); v1x = int(random(0, COLS)); v1y = int(random(0, ROWS)); v2x = int(random(0, COLS)); v2y = int(random(0, ROWS)); } Visualization # Background # Color Shading is a technique that allows us to create a smooth transition between two or more colors. This technique is used in many applications, such as in the creation of gradients, shadows, and even in the creation of 3D objects. The color shading technique is based on the interpolation of colors. I.e., the color of a pixel is calculated by interpolating the colors of the vertices of the triangle that contains the pixel. The interpolation is done by calculating the barycentric coordinates of the pixel with respect to the triangle. The barycentric coordinates are calculated by solving the following system of equations: $$ \\begin{cases} \\alpha x_0 + \\beta x_1 + \\gamma x_2 = x\\\\ \\alpha y_0 + \\beta y_1 + \\gamma y_2 = y \\end{cases} $$ Where $(x_0, y_0)$, $(x_1, y_1)$, and $(x_2, y_2)$ are the coordinates of the vertices of the triangle, and $(x, y)$ are the coordinates of the pixel. The solution of the system of equations is given by: $$ \\begin{cases} \\alpha = \\frac{(y_1 - y_2)(x - x_2) + (x_2 - x_1)(y - y_2)}{(y_1 - y_2)(x_0 - x_2) + (x_2 - x_1)(y_0 - y_2)}\\\\ \\beta = \\frac{(y_2 - y_0)(x - x_2) + (x_0 - x_2)(y - y_2)}{(y_1 - y_2)(x_0 - x_2) + (x_2 - x_1)(y_0 - y_2)}\\\\ \\gamma = 1 - \\alpha - \\beta \\end{cases} $$ The color of the pixel is calculated by interpolating the colors of the vertices of the triangle. The interpolation is done by multiplying the color of each vertex by its barycentric coordinate and adding the results. The result is the color of the pixel. $$ \\begin{cases} r = \\alpha r_0 + \\beta r_1 + \\gamma r_2\\\\ g = \\alpha g_0 + \\beta g_1 + \\gamma g_2\\\\ b = \\alpha b_0 + \\beta b_1 + \\gamma b_2 \\end{cases} $$ Where $r_0$, $g_0$, and $b_0$ are the red, green, and blue components of the color of the first vertex, respectively. The same applies for the other vertices.\nBibliography # Barycentric coordinates Codigo basado de los ejemplos libreria p5.quadrille.js "},{"id":10,"href":"/Talleres/docs/Workshop/workshop_2/rasterization/textureMapping/","title":"Texture Mapping","section":"Rasterization","content":" Texture mapping # Code # Texture mapping Code \u0026#34;use strict\u0026#34;; const ROWS = 20; const COLS = 20; let LEN; let quadrille; let row0, col0, row1, col1, row2, col2; let pg2, pg1; let img; let u0, v0, u1, v1, u2, v2, u3, v3; let button1, button2; function preload() { img = loadImage(\u0026#34;/Talleres/sketches/taller2/graphics.jpg\u0026#34;); } function setup() { createCanvas(700, 350); pg1 = createGraphics(width / 2, height); pg2 = createGraphics(width / 2, height); LEN = width / (COLS * 2); quadrille = createQuadrille(20, 20); pg2.rectMode(CENTER); img.resize(pg2.width, pg2.height); randomize(); button1 = createButton(\u0026#34;Randomize\u0026#34;); button1.position(10, height - 20); button1.mousePressed(() =\u0026gt; randomize(false)); } function draw() { pg1.background(\u0026#34;black\u0026#34;); drawQuadrille(quadrille, { graphics: pg1, cellLength: LEN, outlineWeight: 1, outline: \u0026#34;green\u0026#34;, board: true, }); pg1.push(); pg1.stroke(\u0026#34;cyan\u0026#34;); pg1.strokeWeight(3); pg1.noFill(); pg1.triangle( col0 * LEN + LEN / 2, row0 * LEN + LEN / 2, col1 * LEN + LEN / 2, row1 * LEN + LEN / 2, col2 * LEN + LEN / 2, row2 * LEN + LEN / 2 ); pg1.fill(\u0026#34;red\u0026#34;); pg1.rect(col0 * LEN, row0 * LEN, LEN); pg1.fill(\u0026#34;green\u0026#34;); pg1.rect(col1 * LEN, row1 * LEN, LEN); pg1.fill(\u0026#34;blue\u0026#34;); pg1.rect(col2 * LEN, row2 * LEN, LEN); pg1.pop(); image(pg1, 0, 0); pg2.image(img, 0, 0); pg2.push(); pg2.stroke(\u0026#34;magenta\u0026#34;); pg2.strokeWeight(3); pg2.noFill(); pg2.triangle(u1, v1, u2, v2, u3, v3); pg2.fill(\u0026#34;red\u0026#34;); pg2.rect(u1, v1, LEN); pg2.fill(\u0026#34;green\u0026#34;); pg2.rect(u2, v2, LEN); pg2.fill(\u0026#34;blue\u0026#34;); pg2.rect(u3, v3, LEN); pg2.pop(); image(pg2, width / 2, 0); } function randomize(sync = false) { u1 = int(random(0, img.width)); v1 = int(random(0, img.height)); u2 = int(random(0, img.width)); v2 = int(random(0, img.height)); u3 = int(random(0, img.width)); v3 = int(random(0, img.height)); row0 = round(map(v1, 0, img.height, 0, COLS)); col0 = round(map(u1, 0, img.width, 0, ROWS)); row1 = round(map(v2, 0, img.height, 0, COLS)); col1 = round(map(u2, 0, img.width, 0, ROWS)); row2 = round(map(v3, 0, img.height, 0, COLS)); col2 = round(map(u3, 0, img.width, 0, ROWS)); quadrille.clear(); img.loadPixels(); quadrille.rasterizeTriangle( row0, col0, row1, col1, row2, col2, texturize, [u1, v1], [u2, v2], [u3, v3] ); } function texturize({ pattern: texcoords2 }) { let index = 4 * (int(texcoords2[1]) * img.width + int(texcoords2[0])); return color(img.pixels[index], img.pixels[index + 1], img.pixels[index + 2]); } Visualization # Background # Texture mapping is a technique that allows us to apply a texture to a 3D object. This technique is used in many applications, such as in the creation of 3D models, in the creation of video games, and in the creation of 3D animations. The texture mapping technique is based on the interpolation of texture coordinates. I.e., the texture coordinates of a pixel are calculated by interpolating the texture coordinates of the vertices of the triangle that contains the pixel. The interpolation is done by calculating the barycentric coordinates of the pixel with respect to the triangle. The barycentric coordinates are calculated by solving the system of equations, which is the same as the one used in the color shading technique.\nBibliography # Barycentric coordinates Codigo basado de los ejemplos del docente "}]